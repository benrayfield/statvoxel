# statvoxel

UPDATE: movement in 3d works, see pic below...

<img src=https://raw.githubusercontent.com/benrayfield/statvoxel/main/data/statvoxel/statvoxel_2020-12-22-3p_ScreenPixels512x512_mutableAftrans4x4.jpg>

UPDATE: its now displaying 512x512 video as a test, but its still just random voxels, not mouse painting them in interesting combos yet.

Each voxel has position in a cube of size 2^16 x 2^16 x 2^16 and 15 bit color, but can expand it to bigger spaces using pairs of longs later. Random voxels are now displayed. Experimenting with web of nodes each containing a long[] and java.util.function.LongToIntFunction where "each bucket contains at most 1 long. If it contains 0 longs, maybe just use the constant 0 to mean that? buckets[voxelToBucket.applyAsInt(voxel)] = voxel, for some voxel but one voxel can replace another voxel in the same bucket, depending on order they enter this node. Next one in overwrites the previous one in, or its 0.". Each Node has a sortVal to control which is read and written. (in theory...) All possible random interactions between any pair of nodes converges to exactly the same node states, as long as no 2 nodes have exactly the same sortVal,
but that might take a long time and it will approx converge gradually in realtime, so use it like fluid mixing... LongConsumer is allowed to see any long that exists in a Node of higher sortVal than this Node's sortVal, like if Node.sortVal is index of that Node in a Node[],
and to read from all other nodes you put a Node at index 0, and to write to all other nodes you put it at index Node[].length-1. BUT thats only if all nodes have enough gas to do that many calculations/sharingOfLongs. Gas is like attention or energy. Expecting ability to 3d paint and carve out 3d volumes and move around the space like a FPS or racing game, and ability to display as fisheye lens (maybe), vibrating fluid lens (maybe), partially-turning-a-sphere-inside-out lens (maybe), or near any simple view of long->int as the screen pixels will themselves be just another node which has 1 bucket per x y, and each bucket can have at most 1 long voxel.

"things far away occur less often but are the same size as things near"

The goal of this project is to randomly select from near voxels, by a chosen nonlinear function (such as linear or squared), to display a small near subset of 1 gigavoxel per video frame per computer, potentially in a space of many more voxels from distant/multiplayer sources but want to get it working on 1 computer first.


I need voxel graphics, not even high resolution or competitive with the newest games. But I want to be able to imagine and play with huge worlds, of static (constant position and color) voxels at each place and time. If each voxel is an int64 (aka long) and there are 100000 voxels displayed at once, then that would be long[100000], of maybe 1 billion longs available to display. Lets call that long[d] sortedVoxelsToDisplay. Theres some function(number)->number that maps any voxel into an index in sortedVoxelsToDisplay. The farther away it is, the higher the index in sortedVoxelsToDisplay. Newtonian gravity is by inverse distance squared cuz surface area of a sphere increases by square of the distance, like volume increases by cube of distance. In the most basic case, the function is linear (exponent 1) of the distance from viewing position, so sortedVoxelsToDisplay[500] is 500 times some constant distance from here, and sortedVoxelsToDisplay[501] is 501 times some constant distance from here, and so on, but it doesnt have to be linear. Its probably best to be linear so the number of voxels displayed is viewDepth times area of the screen, instead of increasing beyond screen area, or maybe even less than linear, but linear seems to be the best balance, in theory.

From such statistical distribution of, for example a billion longs/voxels (loaded locally into memory, of potentially a much larger set of voxels such as 3d voxels of the whole planet, but lets keep it simple for now, on the scale of games you play locally)... From that a voxel is chosen at random, that tends to be near the viewing position. The mutable sortedVoxelsToDisplay[] contains for example 100000 voxels. The incoming voxel's distance from this viewing position is translated (by some "nonlinear function (such as linear or squared)") to a specific integer index in sortedVoxelsToDisplay, which it overwrites the long (or however many bits the voxel has, such as long), then repeat many times. After that happens many times, 1/60 second has passed (or however often you like your FPS, to balance between number of voxels, resolution, and lag)...

Then the display happens. Reusing an existing array such as java BufferedImage of 1024x1024, or whatever resolution you want to pay computing resources for (which is stretchable more efficiently than directly writable due to higher level memory IO limits)... Loop from high to low index in sortedVoxelsToDisplay, and display each voxel as a 2d square (in the simplest case, or circles might look better) of some small constant 2d size, of its x y z translated to screenX and screenY, and constant size on screen (regardless of distance, so things far away occur less often but are the same size as things near, and tend to have things nearer displayed in front of them), display it in that color, then continue the loop toward lower index aka voxels nearer. Then repeat the whole process approx 1/60 second later from a different viewing position and different set of voxels which some may have been added and some removed from the for example 1 billion voxels in this computer's memory.

This is just a very very basic model of voxel graphics, which could later maybe have bumpmapping added (per voxel, 1 bump each, like opengl light sources (which I could easily compute 300 moving variable color light sources in realtime to all 100000 bumps/voxels using opencl ndrange kernel, BUT NO SHADOWS cuz those are far more expensive more similar to raytracing), but for now is just a color at a 3d position, going for brute force of very very many of them displayed at once). It would look a little like fizzling heat appearing and disappearing, or radio static or a tv tuned to no signal, a little, but mostly converge to a stable image of high detail. I'm not saying its great graphics, but it would allow me and maybe others who want to explore this kind of possible tool, to paint things we imagine, to explore quickly without much effort, things we might imagine and have other tools generate, without needing large complex tools. It would be something thats just a few kilobytes of code plus java BufferedImage or js html canvas or whatever other system it might be ported to. Its a quick and easy way to, in theory, navigate a space of a billion cartoony local voxels. That is, if can get the statistics to select from those voxels that happen to be near a chosen 3d position, in proportion to the "chosen nonlinear function (such as linear or squared)" (by default, each linear distance from here is equally likely as every other linear distance, so you should get about the same number of voxels randomly selected at distance 500 as distance 5000 and distance 501 and distance 5001, for example. Its just something really simple to start with.

disorganized stuff I wrote above, moved down here, with some duplication[[[

"things far away occur less often but are the same size as things near" and less directly relevant to this project "I have tamed the beast of lambda so it will no longer bite us with halting problem though mathematically it is still possible of a vanishingly small chance, it is now friendlier than a cat". So please, advocates of procedural programming, do not be afraid of lambda anymore, maybe we can gradually learn to make more use of it, as far as the methods I advocate may be used to further tame those lambdas relevant to you, but of course wild lambdas are still scary. For those who doubt it is a beast, I will let it loose within this zoo, this cage, this sandbox, this near endless play space of voxels and dimensions, which personally I do very much need to help me imagine and think through the logic of it all, this graphics system called statvoxel which such things may be plugged into.

The goal of this project is to randomly select from near voxels, by a chosen nonlinear function (such as linear or squared), to display a small near subset of 1 gigavoxel per video frame per computer, potentially in a space of many more voxels from distant/multiplayer sources but want to get it working on 1 computer first.

I need voxel graphics (for a proof of concept of lambdasmiter, that you might experience a little similar to some old 3d game, but with drag-and-droppable functions that you drag function onto function to find/create function, as needed but more often just chill out in the 3d space or as many dimensions as you like, but just 3d and near endless and turing complete possibilities), nothing fancy (of the graphics), not even high resolution or competitive with the newest games. But I want to be able to imagine and play with huge worlds (especially where we may all paint lambda functions (any turing complete possible behaviors) within such a volume of possible spaces, as I have tamed the beast of lambda so it will no longer bite us with halting problem though mathematically it is still possible of a vanishingly small chance, it is now friendlier than a cat and has far more potential uses), of static (constant position and color) voxels at each place and time. If each voxel is an int64 (aka long) and there are 100000 voxels displayed at once, then that would be long[100000], of maybe 1 billion longs available to display. Lets call that long[d] sortedVoxelsToDisplay. Theres some function(number)->number that maps any voxel into an index in sortedVoxelsToDisplay. The farther away it is, the higher the index in sortedVoxelsToDisplay. Newtonian gravity is by inverse distance squared cuz surface area of a sphere increases by square of the distance, like volume increases by cube of distance. In the most basic case, the function is linear (exponent 1) of the distance from viewing position, so sortedVoxelsToDisplay[500] is 500 times some constant distance from here, and sortedVoxelsToDisplay[501] is 501 times some constant distance from here, and so on, but it doesnt have to be linear. Its probably best to be linear so the number of voxels displayed is viewDepth times area of the screen, instead of increasing beyond screen area, or maybe even less than linear, but linear seems to be the best balance, in theory.

]]]

TODO...

